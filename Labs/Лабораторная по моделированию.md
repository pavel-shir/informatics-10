# Лабораторная по моделированию

Перед постановкой задачи лабораторной напомню необходимую теорию.

## Модель обслуживания в банке

Цель - смоделировать работу офиса клиентского обслуживания в банке.

Будем считать, что:

* За 1 минуту в банк входит случайное количество клиентов.
* На обслуживание клиента требуется от $T_{min}$ до $T_{max}$ минут

Модель будет строится на интервале в $L$ минут.

Нам необходимо смоделировать работу офиса с $K$ кассами, и определить _уровень обслуживания_ (подробнее о нём - ниже) с таким количеством касс.

Каждую минуту в банк входит $P_i$ клиентов, количество обслуженных клинтов за эту минуту обозначим $R_i$.

В таком случае количество клиентов в банке определяется по следующей формуле:

$N_{i+1} = N_i + P_i - R_i$

Если считать, что клиенты равномерно распределяются по окнам - то средняя длина очереди равна $Q = \frac{N}{K}$, а среднее время ожидания равно $Q * T$.

Для начала будем считать, что распределение случайного количества клиентов _равномерно_, в этом случае на языке Python его можно получить так:

```Python
# С использованием модуля random
import random
P = random.randint(0, Pmax)

# С использованием numpy
# В randint из numpy верхняя граница интервал не генерируется
import numpy as np
P = np.random.randint(0, Pmax + 1)
```

Если каждый кассир обслуживает клиента за $T$ минут, то за минуту он сделает работу равную $\frac{1}{T}$.

В этом случае $K$ касс за минуту обслуживают $\frac{K}{T}$ клиентов.

Для упрощения модели каждую минуту будем определять время облуживания $T$ случайным образом:

```Python
import random
T = random.randint(Tmin, Tmax)
```

Тогда среднее время ожидания можно рассчитать по формуле $w=Q*T=\frac{N}{K}*T$.

Теперь введем $M$ - максимально допустимое время ожидания.

В этой модели мы не можем гарантировать, что время ожидания никогда не превысит $M$ - т.к. модель вероятностная.

Введем новую метрику - _уровень сервиса_ (service level, в дальнейшем SL) которая считается как доля времени (обычно считается в процентах), когда оценка среднего времени ожидания на превышает $M$.

Более детально: раз мы моделируем каждую минуту отдельно, и для каждой минуты будем считать среднее время ожидания $w$, то обозначим через $L_{sl}$ количество минут, когда среднее время ожидания $w \le M$. В этом случае SL считается по формуле:

$SL = 100 * \frac{L_{sl}}{L}$

где $L$ - количество минут, которые мы моделируем.

### Код для генерации списка со средним временем ожидания для каждой минуты

```Python
from random import randint

L = 10      # Интервал для моделирования, в минутах
K = 5       # Количетсво касс
N = 0       # Количество клиентов в банке в начале
Pmax = 4    # Максимальное число клиентов за 1 минуту
Tmin = 1    # Минимальное время обслуживания клиента 
Tmax = 9    # Максимальное время обслуживания клиента
y = []      # Список, в который будем помещать среднее время ожидания

for i in range(1, L + 1):
    P = randint(0, Pmax)
    T = randint(Tmin, Tmax)
    R = K // T
    N += P - R
    # На случай, если кассы могут обслужить больше клиентов, чем есть в банке
    N = max(N, 0)
    w = N / K * T
    y.append(w)

print(y)
```

## Распределение Пуассона

[Wikipedia](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%9F%D1%83%D0%B0%D1%81%D1%81%D0%BE%D0%BD%D0%B0)

С точки зрения теории массового обслуживания случайные события распределены не _равномерно_, а согласно распределению Пуассона.

Приведу пример кода, которым можно сгенерировать случайное число согласно распределению Пуассона:

```Python
# С помощью numpy
import numpy as np

Pavg = 2
for i in range(10):
    print(np.random.poisson(Pavg))
```

```Python
# Без применения numpy
from math import exp
from random import random

def poisson(Pavg):
    r = exp(-Pavg)
    s = r
    k = 0
    alpha = random()
    while s < alpha:
        k += 1
        r *= Pavg / k
        s += r
    return k

Pavg = 2
for i in range(10):
    print(poisson(Pavg))
```

Код выше выведет 10 случайных чисел распределнных согласно распределению Пуассона.

Стоит отметить, что на вход генерирующей функции подается не _максимальное_, а _среднее_ значение, которое мы хотим сгенерировать - в нашей модели это будет _среднее_ количество клиентов за 1 минуту.

## Matplotlib для генерации графиков

Одной из задач лобараторной работы является генерации графиков, для чего необходимо использовать `matplotlib`, в частности нас будут интересовать [гистограммы](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D1%81%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0).

Код для генерации простой гистограммы из 1000 случайных чисел:

```Python
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots()
dist = [np.random.poisson(10) for _ in range(1000)]
ax.hist(dist)
plt.show()
```

Через параметр `figsize` можно задать размер (в дюймах) рисунка в формате `(width, height)`:

```Python
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(10, 4))
dist = [np.random.poisson(10) for _ in range(1000)]
ax.hist(dist)
plt.show()
```

Графику и осям можно задать подписи:

```Python
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots()
dist = [np.random.poisson(10) for _ in range(1000)]
ax.set_title('Подпись графика')
ax.set_xlabel('Подпись оси X')
ax.set_ylabel('Подпись оси Y')
ax.hist(dist)
plt.show()
```

На одном рисунке можно расположить несколько графиков в ряд задав параметр `ncols`. Обратите внимание на то, как идет обращение к переменной `ax` в этом случае:

```Python
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots(ncols=2)

dist1 = [np.random.poisson(10) for _ in range(1000)]
ax[0].set_title('Подпись первого графика')
ax[0].hist(dist1)

dist2 = [np.random.randint(0, 21) for _ in range(1000)]
ax[1].set_title('Подпись второго графика')
ax[1].hist(dist2)

plt.show()
```

Аналогично можно задать и несколько рядов через параметр `nrows`. В этом случае для того, чтобы исключить наложение подписей графиков друг на друга при фиксированном размере рисунка рекомендуется также задать параметр `layout` со значением `'constrained'`:

```Python
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(15, 8), layout='constrained')

dist1 = [np.random.poisson(10) for _ in range(1000)]
ax[0, 0].set_title('Ряд 1, колонка 1')
ax[0, 0].hist(dist1)

dist2 = [np.random.randint(0, 21) for _ in range(1000)]
ax[0, 1].set_title('Ряд 1, колонка 2')
ax[0, 1].hist(dist2)

dist3 = [np.random.poisson(5) for _ in range(1000)]
ax[1, 0].set_title('Ряд 2, колонка 1')
ax[1, 0].hist(dist3)

dist4 = [np.random.laplace(0, 1) for _ in range(1000)]
ax[1, 1].set_title('Ряд 2, колонка 2')
ax[1, 1].hist(dist4)

plt.show()
```

Обратите внимеание на обращение к переменной `ax`.

Также можно заметить, что при генерации нескольких похожих графиков дублируется много кода.

В этом случае можно воспользоваться циклом:

```Python
import numpy as np
import matplotlib.pyplot as plt

totalRows = 3       # Количество рядов
fig, ax = plt.subplots(nrows=totalRows, ncols=2, figsize=(10, 8), layout='constrained')

totalNums = 100     # Количество генерируемых чисел
for row in range(totalRows):
    x = list(range(1, totalNums))
    y = [np.random.poisson(10) for _ in range(1, totalNums)]
    ax[row, 0].set_title(f'Ряд {row + 1}, гистограмма')
    ax[row, 0].hist(y)
    ax[row, 1].set_title(f'Ряд {row + 1}, график')
    ax[row, 1].plot(x, y)

plt.show()
```

## Jupyter notebook

Лабораторную работу необходимо выполнять в Jupyter notebook.

Предлагается два варианта для выполнения работ с использованием Jupyter через web:

* [Google Colaboratory](https://colab.research.google.com/drive/)

* [Jupyter.org](https://jupyter.org/try-jupyter/lab/)

Для Colaboratory понадобится учетка Google, но при этом будет вся проделанная работа сохраняется в облаке на вашем аккаунте (рекомендуемый вариант).

Jupyter.org доступен без авторизации, но при этом работу придется сохранять на компьютер / внешний носитель / в облако и загружать заново каждый раз.

## Постановка задачи лабораторной работы

В работе необходимо смоделировать работу офиса обслуживания банка для $K \in [1, 10]$.

Параметры модели:

| Обозначение | Значение | Описание |
|-|-|-|
|$L$|480|Количество минут|
|$M$|15|Максимально допустимое время ожидания|
|$P_{max}$|4|Максимальное число новых клиентов за минуту (для равномерного распределения)|
|$P_{avg}$|2|Среднее число новых клиентов за минуту (для распределения Пуассона)
|$T_{min}$|1|Минимальное время обслуживания|
|$T_{max}$|9|Максимальное время обслуживания|

Все обозначенны выше параметры модели должны задаваться как переменные в начале кода, в дальнейшей работе работать только с переменными.

Для каждого $K$ необходимо смоделировать работу **два раза**:

* Случайное число новых клиентов генерирутся равномерно
* Случайное число новых клиентов генерирутся по Пуассону

Случайное время обслуживания всегда генерируется равномерно.

Генерировать списки со средним временем ожидания необходимо через функцию, в которую будут передаваться все параметры модели, а возвращать функция будет список $w$.

Для подсчета $SL$ также необходимо написать отдельную функцию - она по передаваемому списку $w$ и $M$ будет отдавать $SL$.

Для каждого случая (которых, в итоге, получается 20) необходимо нарисовать гистограмму среднего времени ожидания.

Гистограммы для случаев равномерного распределения и распределения Пуассона с одинаковыми $K$ необходимо показать на одном рисунке (т.е. два графика в одном ряду, в виде двух колонок).

Графики необходимо подписать, в подписи должны содержаться:

* $K$, для которого происходило моделирование
* Тип распределения
* Посчитанный $SL$, в процентах

Для сдачи работы **необходимо**:

* Продемонстрировать работу модели с графиками
* Ответить на вопросы на понимание модели
* Ответить на вопросы на к написанному коду

Если выполнение / сдача работы затянется - разрешается завершить работу дома и отправить мне Jupyter notebook файл (тот, что с расширением `.ipynb`), но опрос по работе все равно будет проходить очно.
