# Работа с файлами

Python поддерживает работу с множеством различных типов файлов, которые условно можно разделить на две категории - _текстовые_ и _бинарные_.

Текстовые файлы - такие файлы, информацию из которых отобразить в виде текста. К примеру, `.txt` и `.py` можно открыть в текстовом редакторе и прочитать в виде человеко-читаемого текста.

Бинарные файлы - файлы, в которые записана произвольная последовательность байтов. К таким можно отнести изображения или видеофайлы.

Часто _текстовые_ файлы противопоставляются _бинарным_, но, строго говоря, деление на такие категории является не совсем точным: любой файл (в том числе и _текстовый_) состоит из последовательности байт, и поэтому является _бинарным_.

При работе с файлами необходимо соблюдать следующую последовательность операций:

1. Открытие файла (метод `open()`)
2. Работа с файлом (чтение из файла или запись в него)
3. Закрытие файла (метод `close()`)

Некоторые конструкции Python позволяют опустить явное закрытие файла, они будут рассмотрены ниже.

## Открытие и закрытие файла

Чтобы начать работу с файлом, его надо открыть с помощью функции `open()`, которая чаще всего записывается в следующем виде:

    open(filename, mode, encoding)

В этом примере `filename` - это имя открываемого файла, `mode` - это режим, в котором открывается файл, а `encoding` - кодировка, которую нужно использовать при работе с файлом.
Параметр `encoding` используется только при работе с текстовыми файлами.

На самом деле у функции `open()` несколько больше параметров, с которыми можно ознакомиться [в документации](https://docs.python.org/3/library/functions.html#open).

`filename` может быть _абсолютным_ путём до файла (C:\temp\input.txt), так и _относительным_ путём (temp\input.txt).
При использовании _относительного_ пути поиск файла будет идти относительно запускаемого скрипта.

Режим работы с файлом может принимать следующие значения:

Режим | Название | Значение
--|--|--
`'r'` | read | Открытие на чтение (является значением по умолчанию)
`'w'` | write | Открытие на запись. Содержимое файла удаляется. Если файла не существует, создается новый
`'x'` | exclusive creation | Открытие на эксклюзивную создание, выбрасывает исключение если файл уже существует
`'a'` | append | Открытие на дозапись, информация добавляется в конец файла
`'b'` | binary | Открытие в бинарном режиме
`'t'` | text | Открытие в текстовом режиме (является значением по умолчанию)
`'+'` | | Открытие на чтение и запись

Некоторые режимы можно комбинировать - запись `rb` означает _чтение в бинарном режиме_, а `wt` - _запись в текстовом режиме_. Текстовый режим `t` является значением по умолчанию, поэтому его зачастую опускают и вместо `rt` и `wt` указывают `r` и `w`.

 Режимы `r`, `w`, `x` и `a` комбинировать в записи нельзя.

Режимы `r+` и `r+b` открывают файл на чтение и запись, при этом содержимое файла не удаляется.

При испольовании режимов `w+` и `w+b` файл откроется на чтение и запись, при этом его содержимое будет удалено.

Параметр `encoding` отвечает за кодировку, этот параметр должен использоваться только в _текстовом_ режиме. Список поддерживаемых кодировок можно посмотреть [в документации](https://docs.python.org/3/library/codecs.html#standard-encodings).

Параметр `encoding` нужен потому, что один и тот же символ в разных кодировках может кодироваться разным набором байт, а интерпретатору необходимо однозначно понимать какие символы нужно вернуть по прочитанному набору байт (при чтении) или какие байты необходимо записать в файл по переданному набору символов (при записи).

В _бинарном_ режиме параметр `encoding` указывать не нужно, потому как байты читаются и пишутся напрямую, без промежуточного шага кодирования или декодирования.

Пример открытия файла на чтение:

    f = open('input.txt', 'r')

В примере выше в переменной `f` будет находиться _файловый объект_. Читать или писать в файл мы будем работая с переменной `f`.

После открытия файла мы можем работать с ним (писать или читать, в зависимости от использованного режима).

В конце работы файл **необходимо** закрыть с помощью метода `close()`:

    f.close()

После закрытия файла читать и писать в него уже нельзя.

## Конструкция with .. as

Простой способ работы с файлом выглядит так:

    # Файл открывается на чтение
    f = open('input.txt', 'r')
    # Содержимое файла читается в переменную s
    s = f.read()
    # Файл закрывается
    f.close()

Альтернативой является конструкция `with .. as ..`:

    with open('input.txt', 'r') as f:
        s = f.read()

Во втором случае не нужно явно закрывать файл с помощью `close()` - файл автоматически закроется при выполнения всех инструкций внутри блока `with .. as`.
Стоит отметить, что файл закроется даже если в ходе работы с ним будет выброшено исключение.

## Методы чтения файлов

При открытии файлов в текстовом режиме методы чтения будут возвращать тип `str` (или массивы `str`).

При открытии файлов в бинарном режиме методы чтения будут возвращать тип `bytes` (или массивы `bytes`).

Для демонстрации методов чтения представим, что есть файл `input.txt` следующего содержания:

    Hello
    World
    !!!

### `read()`

Метод `read()`, если запустить его без параметра, читает файл с текущей позиции до конца:

    >>> f = open('input.txt', 'r')
    >>> f.read()
    'Hello\nWorld\n!!!'

Можно заметить специальные символы `\n` в записи прочитанной строки - это символы переноса строки.

На разных платформах символы переноса строк могут отличаться: это могут быть `\n`, `\r` и `\r\n`.
Для того, чтобы добиться большей платформо-независимости в Python3 по умолчанию все переносы строк преобразуюются в символ `\n`.

Если метод `read()` запустить с параметром `size` то будет прочитано столько данных, сколько задано параметром `size`.

К примеру, в текстовом режиме `f.read(5)` вернет 5 _символов_ начиная с текущей позиции, а в бинарном режиме вернет 5 _байт_ начиная с текущей позиции:

    >>> f = open('input.txt', 'r')
    >>> f.read(5) 
    'Hello'
    >>> f.read(5)
    '\nWorl'
    >>> f.read(5)
    'd\n!!!'
    >>> f.read(5)
    ''

Можно заметить, что метод `read()` передвигает текущую позицию указателя.

Если указатель находится в конце файла - метод `read()` вернет пустую строку.

Если указатель находится не в конце файла, но до конца файла осталось менее `size` символов, то `read(size)` просто вернет все оставшиеся до конца файла символы.

Для того, чтобы определить где в данный момент находится указатель, можно воспользоваться методом `tell()`:

    >>> f = open('input.txt', 'r')
    >>> f.read(5)
    'Hello'
    >>> f.tell()
    5

Если нужно читать файл не с самого начала - можно воспользоваться методом `seek()`:

    >>> f = open('input.txt', 'r')
    >>> f.seek(4)
    4
    >>> f.read(5)
    'o\nWor'

`seek(4)` в данном примере двигает указатель на 4 **байтa** относительно начала файла.

Методом `seek()` можно двигать указатель не только относительно начала файла - для этого необходимо передать ему второй параметр.
К примеру, `seek(4, 1)` подвинет указатель на 4 байта относительно _текущей позиции_, а `seek(-3, 2)` подвинет указатель на третий байт с конца.

Стоит учесть, что в зависимости от кодировки и записанного текста символы могут занимать как один, так и несколько байт.

К примеру, в кодировке UTF-8 кириллические символы занимают по два байта. В случае кириллического текста с помощью метода `seek()` можно установить указатель _посередине_ символа, и при дальнейшем чтении результат может оказаться неожиданным.

### `readline()`

Метод `readline()` читает файл с текущей позиции до следующего переноса строки:

    >>> f = open('input.txt', 'r')
    >>> f.readline()
    'Hello\n'
    >>> f.readline()
    'World\n'
    >>> f.readline()
    '!!!'

Стоит заметить, что символ переноса строки попадает в прочитанные данные.
Если от символа переноса строки нужно избавиться, можно воспользоваться методом `strip()`:

    >>> f = open('input.txt', 'r') 
    >>> s = f.readline()
    >>> print(s.strip())
    Hello

Если нужно прочитать и обработать все строки из файла, можно читать данные из файла пока метод `readline()` не будет возвращать пустую строку:

    f = open('input.txt', 'r')
    while True:
        s = f.readline()
        if s == '':
            break
        print(s.strip())
    f.close()

Результатом данного скрипта будет:

    Hello
    World
    !!!

Для удобства в Python можно пробежать по всему файлу циклом `for`:

    for s in open('input.txt', 'r'):
        print(s.strip())

Результат у этого скрипта будет такой же, как и у предыдушего - будут выведены все строки из файла `input.txt`.

### `readlines()`

Если необходимо прочитать сразу все строки файла начиная с текущей позиции и поместить их в массив - можно воспользоваться методом `readlines()`:

    >>> f = open('input.txt', 'r')
    >>> a = f.readlines()
    >>> f.close()
    >>> print(a)
    ['Hello\n', 'World\n', '!!!']

## Методы записи в файл

Для записи можно использовать несколько режимов:

- `'w'` (запись с предварительной очисткой файла)
- `'x'` (эксклюзивное создание с проверкой существования файла)
- `'a'` (дописывание в конец)
- `'r+'` (чтение + запись, без очистки файла)

При записи в файл также можно пользоваться методами `seek()` и `tell()` для изменения положения указателя.

В текстовом режиме записывать в файл можно данные типа `str`, в бинарном - типа `bytes`.

### `write()`

Метод `write()` принимает один параметр - записываемые данные:

    f.open('output.txt', 'w')
    f.write('Hello, World!')
    f.close()

В результате в файле `output.txt` окажется следующее содержимое:

    Hello, World!

Если после записи в файл не вызвать метод `close()` - то может оказаться, что записаны не все данные, или не записано вообще ничего.

Альтернативно можно воспользоваться конструкцией `with .. as`, при использовании которой нам не нужно явно вызывать метод `close()` - это будет сделано автоматически:

    with open('output.txt', 'w') as f:
        f.write('Hello, World!')

Результат у этого скрипта будет таким же.

Если в файл необходимо записать несколько строк - необходимо это явно указывать с помощью символа переноса строки `\n`:

    f = open('output.txt', 'w')  
    f.write('Hello,\n')
    f.write('World!')   
    f.close()

В результате этого скрипта содержимое `output.txt` окажется следующим:

    Hello,
    World!

Представим такую задачу - необходимо записать список чисел в файл, в одной строке через пробел. Для этого сначала числа из массива нужно перевести в строки, а после этого сконкатенировать полученные строки с помощью пробельного символа, и полученную строку записать методом `write()`:

    a = [1, 2, 3, 4, 5]     # Исходный массив чисел
    b = list(map(str, a))   # Перевод чисел в строки
    s = ' '.join(b)         # Конкатенация всех строк в одну
    f = open('output.txt', 'w')
    f.write(s)              # Запись полученной строки
    f.close()

В `output.txt` получим следующее:

    1 2 3 4 5

Короче это можно записать следующим образом:

    a = [1, 2, 3, 4, 5]
    with open('output.txt', 'w') as f:
        f.write(' '.join(list(map(str, a))))

Если нужно вывести числа в отдельных строках - вместо пробельного символа можно конкатенировать строки с использованием символа переноса строки `\n`:

    a = [1, 2, 3, 4, 5]
    with open('output.txt', 'w') as f:
        f.write('\n'.join(list(map(str, a))))

В `output.txt` получим:

    1
    2
    3
    4
    5

### `writelines()`

Метод `writelines()` принимает список строк (или что-либо, генерирующее набор строк) и записывает их в файл. Символы переноса строки при этом не добавляются:

    s = ['Hello, ', 'World!']
    with open('output.txt', 'w') as f:
        f.writelines(s)

`output.txt` после запуска предыдущего примера:

    Hello, World!

Для наглядности перпишем прошлый пример с использованием `write()`:

    s = ['Hello, ', 'World!']
    with open('output.txt', 'w') as f:
        for x in s: 
            f.write(x)

Результат данного примера окажется таким же.
